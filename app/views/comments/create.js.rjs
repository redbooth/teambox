# Fetch new comments after post and render them
if @new_comments
  page.insert_html :top, :comments, :text => list_comments(@new_comments, @comment.target)
  page << "$('last_comment_id').writeAttribute('value', #{@last_id})"
end

if @comment.errors.empty?
  unless @comment.new_record?
    page.ef('comments')
      page.insert_html :top, :comments, :partial => 'comments/comment', :locals => { :comment => @comment, :project => @current_project }
    page.esf('activities')
      page.insert_html :top, :activities, show_activity(@comment.activity)
    page.en
    
    display_watchers = !@target.is_a?(Project)
    
    if @target == @task
      if @task.closed?
      #   page.insert_archive_box(@current_project,@task)
      #   page['new_comment'].remove
      #   page['watching'].hide
      #   display_watchers = false
      #   page[task_id(:edit_form,@current_project,@task_list,@task)].remove
      else
        page.replace 'new_comment', new_comment_form(@current_project,@new_comment,:target => @task)
        if @comment.previously_closed?
          page['watching'].show
          page.insert_task_form(@current_project,@task_list,@task)
        end
      end
      # page.update_task(@task)
      # page.replace_task_header(@current_project,@task_list,@task)
    else
      page << "Form.reset('new_comment')"
      page.replace 'upload_area', upload_area(@comment)
      page['comment_upload_link'].show
    end
    
    if display_watchers
      page.update_watching(@current_project,current_user,@target)
    end
    
    page << "Comment.watch_edit();"
    page.reload_javascript_events
  end
  
  page.remove_form_errors(@comment,'new_comment')
  page["comment_#{@comment.id}"].visual_effect :highlight, :duration => 2
else
  page.show_form_errors(@comment,'new_comment')
end

page.call 'Comment.setLoading', 'comment_new', false
